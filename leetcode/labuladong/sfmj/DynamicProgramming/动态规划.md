# 动态规划
动态规划一般都是求最值

判断是否存在最优子结构：子问题间必须互相独立。子问题之间不会相互影响。

## 状态转移方程
1、明确基础条件
2、明确状态，即会变化的变量
3、明确选择，导致状态变化的行为
4、定义dp数组/函数的含义

## 如何看出是否存在重复子问题，即是否可以用备忘录优化
通过递归框架直接判断是否存在重叠⼦问题

## 背包问题
状态：可选择物品i、背包容量w

背包容量装不下第i个物品
dp[i][w] = dp[i-1][w]  w - weight[i] < 0

背包容量可用装下第i个物品
dp[i][w] = max(dp[i-1][w], dp[i][w-weight[i]]+value[i]) w - weight[i] >= 0

## 买卖股票问题
状态：天数n、买卖次数k、持有状态0和1

状态转移公式
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k-1][1]+price[i]) // 昨天没有持有股票和昨天持有股票今天卖掉的最大值
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0]-price[i]) // 昨天持有股票和昨天没有持有股票今天买进的最大值

k=1时
dp[i][0] = max(dp[i-1][0], dp[i-1][1]+price[i])
dp[i][1] = max(dp[i-1][1], -price[i])

k=无穷时
dp[i][0] = max(dp[i-1][0], dp[i-1][1]+price[i])
dp[i][1] = max(dp[i-1][1], dp[i-1][0]-price[i])

冷冻期
dp[i][0] = max(dp[i-1][0], dp[i-1][1]+price[i])
dp[i][1] = max(dp[i-1][1], dp[i-2][0]-price[i])
初始条件需要变化下

手续费
dp[i][0] = max(dp[i-1][0], dp[i-1][1]+price[i])
dp[i][1] = max(dp[i-1][1], dp[i-1][0]-price[i]-fee)
初始条件需要变化下

## 二维矩阵最优化问题
⼀般来说，让你在⼆维矩阵中求最优化问题（最⼤值或者最⼩值），肯定需要递归 + 备忘录，也就是动态规
划技巧。
