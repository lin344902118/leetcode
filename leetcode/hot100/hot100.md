# 1、两数之和
## 解题思路：
思路一：
双层循环判断和是否等于target。
时间复杂度 O(n^2)

思路二：
使用map缓存
for循环，通过判断target减去当前数是否在map中，在则返回两数索引，不在则加入map中
时间复杂度O(n)

## 代码：
twoSum.go

# 2. 两数相加
## 解题思路：
思路一：
链表是倒序的，所以可以直接加，用一个变量add记录是否需要进一。创建虚拟头节点fake
循环直到l1不等于空指针或者l2不等于空指针或者add大于0，新值等于add，如果l1不为空，加上l1的值，l1指向下个指针，l2同。新值除以10作为add，对10取余作为值。创建新节点。虚拟头节点指向该节点，虚拟头节点指向一个指针。
返回虚拟头节点下一个指针

## 代码：
addTwoNumbers.go

# 3. 无重复字符的最长子串
## 解题思路
思路一：
双层for循环遍历

思路二：
使用滑动窗口，用map缓存每个字符串出现次数
循环字符串，计算字符出现次数，如果不大于1，则窗口右移，否则收缩窗口。

## 代码
lengthOfLongestSubstring.go

# 4. 寻找两个正序数组的中位数
## 解题思路
思路一:
创建一个临时数组，容量为m+n的一半加一。
循环添加两个数组的最小元素，直到长度等于容量。根据m+n是奇数还是偶数，取数组最后一个还是最后两位数的平均数。（可以不适用临时数组，只用两个变量记录）

## 代码
findMedianSortedArrays.go

# 5. 最长回文子串
## 解题思路
思路一： 暴力
编写一个函数用于判断是否是回文。用左右双指针，遍历头和尾。如果头尾不相同，则不是。
双层for循环遍历判断最长的子串是否是回文

思路二：
for循环遍历字符串，从0到len(s)-1往外扩张，直到不是回文字符串。每次判断扩张后的长度是否大于之前的结果

## 代码
longestPalindrome.go

# 10. 正则表达式匹配
## 解题思路

## 代码

# 11. 盛最多水的容器
## 解题思路
思路一：暴力破解
双层for循环判断，每次判断两个之间的最小值和间隔的乘积即最小面积
超出时间限制

思路二：双指针
通过双指针记录左右边界
循环直到左指针大于等于右指针，判断面积即左右指针最小值*指针差，记录最大面积。如果左指针是短板，左指针往后，否则右指针往前

## 代码
maxArea.go

# 15. 三数之和
## 解题思路
思路一：双指针
先对数组排序
循环遍历数组，使用双指针记录当前值右边第一个和右边最后一个数。判断其和是否满足条件即二分查找0-当前值
跳过各种重复元素。

## 代码
threeSum.go

# 17. 电话号码的字母组合
## 解题思路
思路一：回溯算法
使用map缓存所有数字以及其字母映射。
然后遍历回溯第一个映射，第二个映射。以此类推

## 代码
letterCombinations.go

# 19. 删除链表的倒数第 N 个结点
## 解题思路
思路一：双指针+虚拟头节点
使用左指针走N步，右指针指针从头开始走。两个指针并排走，直到左指针下一个指针为空。
右指针指向的节点即为倒数第N-1个节点，修改其下一个指针删除第N个节点。

## 代码
removeNthFromEnd.go

# 20. 有效的括号
## 解题思路
思路一：使用堆栈
创建一个数组作为堆栈使用，遇到左括号之类的就入栈，遇到右括号就出栈。判断出栈元素是否符合条件

## 代码
isValid.go

# 21. 合并两个有序链表
## 解题思路
思路一：
创建一个虚拟头节点，判断两个链表值，将小的加入下一个节点。直到两个链表都为空

## 代码
mergeTwoLists.go

# 22. 括号生成
## 解题思路
思路一：使用堆栈
创建两个变量记录左右括号的出现次数，初始化为n。
创建一个字符串数组作为堆栈使用
定义回溯函数，如果索引等于n*2，加入结果集。否则判断下堆栈是否为空，为空只能入栈左括号。
左括号次数减一，再次回溯。如果不为空。遍历左右括号，判断左右括号次数是否用尽。未用尽则对应入栈和出栈。
调用回溯函数
返回结果

思路二：
创建两个变量记录左右括号的出现次数，初始化为n。
定义回溯函数，如果索引等于n*2，加入结果集。判断左括号次数是否小于n，是，加入左括号，并回溯。
否则判断右括号次数是否小于左括号次数，是，加入右括号，并回溯。

## 代码
generateParenthesis.go

# 23. 合并 K 个升序链表
## 解题思路
思路一：
构建一个最小堆。遍历所有的链表将值加入一个数组中，根据数组构建最小堆。然后每次从堆顶取元素构造新链表

## 代码
mergeKLists.go

# 31. 下一个排列
## 解题思路
思路一：
由后往前后判断，是否存在一个数大于其前一个数，如果存在。该前一个数安排合适的位置，之后的数重新排序并返回。如果一直找不到，说明不存在字典序更大的排列，对整个数组排序

## 代码
nextPermutation.go

# 32. 最长有效括号
## 解题思路
思路一：
用一个dp数组，记录相邻元素的合法子串
dp[i]表示i-1结尾最长合法括号子串长度
遇到左括号，将其索引入栈，dp设置为0，遇到右括号，判断栈是否存在元素，不存在，dp设置为0，
存在出栈，获取左括号索引，然后计算长度并加上dp[左括号索引]
遍历整个dp，获取最长子串长度

## 代码
longestValidParentheses.go

# 33. 搜索旋转排序数组
## 解题思路
思路一：
先遍历找到k，然后根据k将数组分成两份，分别使用二分查找

## 代码
search.go

# 34. 在排序数组中查找元素的第一个和最后一个位置
## 解题思路
思路一：
先二分查找到该元素，然后左右扩展找第一个和最后一个

## 代码
searchRange.go

# 39. 组合总和
## 解题思路
思路一：回溯法
使用path记录每次添加数组的结果，sum记录总和
编写回溯函数
如果sum等于target，将path加入结果集。如果sum大于target则返回。
遍历数组，将数值加入path，并计算sum。然后不断往后回溯
之后还原path和sum
调用回溯函数，返回结果

## 代码
combinationSum.go

# 42. 接雨水
## 解题思路
思路一：
找到第一个柱子，然后往后找大于等于它的柱子，计算雨水面积。
找到最大的柱子后，倒过来找。然后两个面积相加

## 代码
trap.go

# 46. 全排列
## 解题思路
思路一：
使用回溯法遍历所有情况,使用一个map数组辅助已经被遍历过的情况。

## 代码
permute.go

# 48. 旋转图像
## 解题思路
思路一：
先按00-11-22-nn这条对角线交换，然后沿中间交换

## 代码
rotate.go

# 49. 字母异位词分组
## 解题思路
思路一：
使用map缓存，key为字符串按字典序排序后的新字符串，value就是字母异为词组合

## 代码
groupAnagrams.go

# 53. 最大子数组和
## 解题思路
思路一：
使用dp数组，表示0到i的连续最大子数组和。如果dp[i-1]的值大于0，选择dp[i-1]加i的值，否则选择i的值。

## 代码
maxSubArray.go

# 55. 跳跃游戏
## 解题思路
思路一：
计算每个位置能达到的最大长度，如果止步不前就返回false。
否则判断最大高度是否大于等于len(nums)-1

## 代码
canJump.go

# 56. 合并区间
## 解题思路
思路一：
先对区间进行升序排序。然后判断是包含还是重叠

## 代码
merge.go

# 62. 不同路径
## 解题思路
思路一：
回溯，时间超出限制
思路二：
动态规划，到end的路径总数等于到end左上角的路径总数加上end左边的路径总数。用map缓存下

## 代码
uniquePaths.go

# 64. 最小路径和
## 解题思路
思路一：
动态规划，到右下角的最小路径等于左边最小路径和右上角最小路径最小值加上自己的值

## 代码
minPathSum.go

# 94. 二叉树的中序遍历
## 解题思路
思路一：递归
先遍历左子树，然后添加根节点数值，然后遍历右子树

## 代码
inorderTraversal.go

# 169. 多数元素
## 解题思路
思路一：
使用map缓存元素出现次数，遍历nums每出现一次，次数加一，如果次数大于len(nums)/2则返回。
思路二：
先排序，然后返回中间索引的数

## 代码
majorityElement.go

# 338. 比特位计数
## 解题思路
思路一：
遍历0到n，将其转为二进制，然后遍历判断有多少个1。加入答案集

## 代码
countBits.go